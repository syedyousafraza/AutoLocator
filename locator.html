<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Locator Generator</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        textarea { width: 100%; height: 150px; margin-bottom: 10px; }
        button { margin: 5px 0; padding: 10px 20px; }
        pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ddd; }
    </style>
</head>
<body>

<h2>Locator Generator</h2>
<textarea id="domInput" placeholder="Paste the DOM here..."></textarea>

<div>
    <button onclick="generateLocators('id')">ID Locators</button>
    <button onclick="generateLocators('class')">Class Locators</button>
    <button onclick="generateLocators('name')">Name Locators</button>
    <button onclick="generateLocators('tag')">Tag Name Locators</button>
    <button onclick="generateLocators('xpath')">XPath Locators</button>
    <button onclick="generateLocators('css')">CSS Locators</button>
</div>

<h3>Generated Locators</h3>
<pre id="output"></pre>

<script>
    function generateLocators(strategy) {
        // Get the value from the textarea where the DOM is pasted
        const domInput = document.getElementById('domInput').value.trim();

        // Check if the textarea is empty
        if (!domInput) {
            document.getElementById('output').textContent = 'Please paste valid HTML content into the textarea.';
            return;
        }

        try {
            // Parse the pasted HTML string into a document object
            const parser = new DOMParser();
            const doc = parser.parseFromString(domInput, 'text/html');

            // Initialize an array to store the locators
            let locators = [];

            // Switch statement to handle different strategies for locator generation
            switch (strategy) {
                case 'id':
                    locators = Array.from(doc.querySelectorAll('[id]')).map(el => `#${el.id}`);
                    break;
                case 'class':
                    locators = Array.from(doc.querySelectorAll('[class]')).map(el => `.${el.className.split(' ').join('.')}`);
                    break;
                case 'name':
                    locators = Array.from(doc.querySelectorAll('[name]')).map(el => `[name="${el.name}"]`);
                    break;
                case 'tag':
                    locators = Array.from(doc.getElementsByTagName('*')).map(el => el.tagName.toLowerCase());
                    break;
                case 'xpath':
                    locators = Array.from(doc.querySelectorAll('*')).map(el => generateXPath(el));
                    break;
                case 'css':
                    locators = Array.from(doc.querySelectorAll('*')).map(el => {
                        const tag = el.tagName.toLowerCase();
                        const id = el.id ? `#${el.id}` : '';
                        const classNames = el.className ? `.${el.className.split(' ').join('.')}` : '';
                        return `${tag}${id}${classNames}`;
                    });
                    break;
                default:
                    locators = ['Invalid strategy selected'];
            }

            // Display the generated locators in the pre element
            document.getElementById('output').textContent = locators.join('\n') || 'No locators found for the selected strategy.';
        } catch (error) {
            // Error handling for invalid HTML
            document.getElementById('output').textContent = 'Invalid DOM input. Please ensure it\'s correct HTML.';
            console.error('Error parsing DOM:', error);
        }
    }

    // Function to generate XPath locators
    function generateXPath(element) {
        if (element.id) return `//*[@id="${element.id}"]`;
        const path = [];
        while (element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();
            if (element.previousElementSibling) {
                let sib = element.previousElementSibling;
                let nth = 1;
                while (sib) {
                    if (sib.nodeName.toLowerCase() === selector) nth++;
                    sib = sib.previousElementSibling;
                }
                selector += `:nth-of-type(${nth})`;
            }
            path.unshift(selector);
            element = element.parentNode;
        }
        return path.length ? `/${path.join('/')}` : null;
    }
</script>

</body>
</html>
